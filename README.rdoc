= Billing Logic
- BillingAccount
- Product
- Subscription

== Structure

    module BillingLogic
      module CommandBuilders
        autoload :BuilderHelpers, 'billing_logic/command_builders/command_builders'
        autoload :BasicBuilder, 'billing_logic/command_builders/command_builders'
        autoload :WordBuilder , 'billing_logic/command_builders/command_builders'
        autoload :AggregateWordBuilder, 'billing_logic/command_builders/command_builders'
        autoload :ActionObject,         'billing_logic/command_builders/command_builders'
        autoload :SINGLE_PRODUCT_REGEX, 'billing_logic/command_builders/command_builders'

      end
      module Strategies
        autoload :BaseStrategy              , 'billing_logic/strategies/base_strategy'
        autoload :IndependentPaymentStrategy, 'billing_logic/strategies/independent_payment_strategy'
        autoload :SinglePaymentStrategy     , 'billing_logic/strategies/single_payment_strategy'
      end
    end

== BillingLogic::Strategies
There currently 2 strategies available:
- IndependentPaymentStrategy: Each product gets its own PaymentProfile
- SinglePaymentStrategy: All products share a single PaymentProfile

    strategy = <strategy class>.new(:payment_command_builder_class => <your builder class>,
    				:current_state => <an array of payment profiles>
    				:desired_state => <an array of products>)
    
    strategy.command_list => An Array of commands provided by the command builder class

== BillingLogic::PaymentProfile
A PaymentProfile must have the following fields
  :id                         # a unique identifier
  :products                   # An array of products
  :next_payment_date          # DateTime of the next due payment
  :billing_cycle              # A BillingLogic::BillingCycle
  :active_or_pending?         # Is this a current, not cancelled nor suspended profile
  :last_refundable_payment    # The amount of the last payment that is refundable

== BillingLogic::Product
A product must provide the following fields
  :id                 # a unique identifier
  :name               # a class of product identifier
  :price              # the common price for this object
  :billing_cycle      # A Billing Cycle like object
  :payments           # an array of payments made, if applicable
  :initial_amount     # The amount of an optional initial payment, if applicable
  :billing_start_date # This will be used for special cases when we don't want to start the billing immediatly

  facility methods
    renewal_month
    renewal_day
    interval
    start_on
    expires_on

== BillingLogic::BillingCycle
constants:
  TIME_UNITS = { :day => 1, :week => 7, :month => 365/12.0, :semimonth=> 365/24, :year => 365 }

fields:
  :frequency (1, 45)
  :period (:day, :week, :semimonth, :month, :year)
  :anniversary

methods:
  days_in_billing_cycle_including(date)
  next_payment_date
  closest_anniversary_date_including(date)
  periodicity ( TIME_UNITS[self.period] * frequency )

== BillingLogic::PaymentCommandBuilder

methods:
  group_products_by_billing_cycle

class methods:
  create_recurring_payment_commands
  cancel_recurring_payment_commands

# == Subscription
# fields:
#   balance
#   plan_id
#   price
#   status
#   trial_duration
#   trial_duration_unit
#   trial_period
# 
# Class methods
#   new
#   create
#   update
#   cancel
#   find
# 
# 
# subscription = Subscription#new or Subscription#create
# subscription.renew
# subscription.cancel
# subscription.activate!
# subscription.deactivate!
# subscription.status #=> pending, active, expired, cancelled, past_due
# subscription.balance
# 
# Subscription.cancel(id)
# 
# == Product
# product = Product.new
# product.amount = 19.00
# 
# == Plan
# fields:
#   plan id
#   plan name
#   description
#   trial period => true/false
#   billing day of month
#   number of billing cycles
#   amount
#   currency
#   billing cycle
# 
# 
# == Addons/Discounts
# id
# name
# descripion
# amount
# duration
# number_of_billing_cycles
# quantity
# never_expires
# 
# == 
# 
# 
# 
# 
